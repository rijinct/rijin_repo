sed
======

sed [options] �<sed-script>� input_file(s)

Options:
-------
 -i � It is used to perform in-place editing.
 -e � It is used to specify multiple scripts with a single sed command.
 -n � It is used to suppress default behavior (displaying all lines from input file, selected lines printed twice) of action, �p?.
 -f � It is used to specify a file that contains sed script.
 -r � It is used for extended regular expressions in the script

Actions:
-------
 All the commands specified below, reads input into buffer from the input file, takes action on the input in the buffer, and send the processed output to standard  output file. These are put in the action, ie, 

 -a � This will append text after specified line.
 -i � This will insert text before specified line.
 -q � This will quit after processing specified line.
 -�r file name? � This will append text read from file name.
 -�R file name? � This will append a line read from file name.
 -d � This will delete specified lines.
 -p � This will print specified lines, if n option is not specified, prints all

Actions:
-------
-�s/regexp/replacement /� - This subsititutes the first occurrence of regular expression regexp (in all matching lines) with the replacement pattern.
-�s/regexp/replacement /g� - This substitutes all occurrences of regular expression regexp (in all matching lines) with the replacement pattern.
-�w file name? - This writes the current pattern space to file name.
-�W file name? � This writes the first line of current pattern space to file name.


sed script consists of address action pair
------------------------------------------
There are two types of addressing, namely:

 -Line addressing
 -Context addressing

  Line addressing is concerned on identifying a set of lines in input file, by specifying the line numbers.
  Context addressing is concerned on identify lines containing matching pattern.


sed: Addressing example
-----------------------
$ cat -n employee1.lst

1 101:mohan:Manager
2 188:Aggarwal:manager
3 102:mahesh:VP
4 105:tarun:manager
5 198:Aggrawal:President
6 109:karan:Clerk

1) $ sed -n '3,5p' employee1.lst

102:mahesh:VP
105:tarun:manager
198:Aggrawal:President


Explanation:
sed prints from the third to the fifth lines from the file employee1.lst. If �n option is not specified, all the lines are printed, and the selected lines are printed twice.

2) $ sed -ne '3p' -ne '6p' employee1.lst

102:mahesh:VP
109:karan:Clerk

3) $ sed '4d' employee1.lst

101:mohan:Manager
188:Aggarwal:manager
102:mahesh:VP
198:Aggrawal:President
109:karan:Clerk

Explanation:
sed removes 4th line from the file employee1.lst, from the scope of the output.

4) $ sed '1i 785:Raj:VP' employee1.lst

785:Raj:VP
101:mohan:Manager
188:Aggarwal:manager
102:mahesh:VP
105:tarun:manager
198:Aggrawal:President
109:karan:Clerk

Explanation:
sed inserts the specified line before the current first line in the file employee1.lst. The file is not
affected, but only scope of the output.

$ sed '$a 189:Paresh:VP' employee1.lst

101:mohan:Manager
188:Aggarwal:manager
102:mahesh:VP
105:tarun:manager
198:Aggrawal:President
109:karan:Clerk
189:Paresh:VP

Explanation:
sed appends the specified line after the last line, in the input file Employee1.lst; only the scope of output is affected.


sed: Context addressing example
-------------------------------

1) $ sed -i '/^105/s/manager/GM/' employee1.lst

$ cat -n employee1.lst
1 101:mohan:Manager
2 188:Aggarwal:manager
3 102:mahesh:VP
4 105:tarun:GM
5 198:Aggrawal:President
6 109:karan:Clerk

Explanation:
sed substitutes the pattern �manager� with �GM� in the file employee1.lst on the line starting with pattern �105�; interactive option -i effects the change in the file.

2) $ who | sed -n '/^murali/p'

murali pts/17 2009-07-09 14:20 (9.122.197.21)
Explanation:
The output of the command �who? is piped to sed; sed displays only those
lines that begin with the pattern �murali?.


sed Regular Expression
-----------------------

A regular expression is a character that has a special meaning to the utility. There are certain characters that are specially interpreted by grep, egrep, sed, awk, and perl.

We have four types of Regular Expressions for sed namely:

 -Basic Regular Expressions (BREs)
 -Extended Regular Expressions (EREs)
 -Interval Regular Expressions (IREs)
 -Tagged Regular Expressions (TREs)


 -Basic Regular Expressions (BREs)
-----------------------------------

Meaning
 
1 *
 This matches zero or more occurrences of preceding character

2 .
 This matches exactly one occurrence of any character

3 ^
 This matches all the lines from input file, that start with the specified pattern

4 $
 This matches all the lines from input file, that end with the specified pattern

5 [ ]
 This is a Character class; the character class can be a list of characters or range of characters; matches one occurrence of any one of the specified characters

6 -
 This is a Range operator


xxx--> tac to reverse the file
Basic Regular Expression examples
---------------------------------

Explanation:
In the above code example, �1,$? refers to a range; it means the address,first line to the last line of the file; sed substitutes all occurrences
(because of the global switch, �g?) of either organization or organization to organization in the file myorg1, specified as parameter. The operator
[ ] refers to character class regular expression.

$cat myorg1
I am IBMer. I have been associated with this organization since past two years. 
This organisation is involved in the following activities:


1) $ sed '1,$s/organi[zs]ation/organization/g' myorg1

Explanation:
In the above code example, �1,$� refers to a range; it means the address, 
first line to the last line of the file; sed substitutes all occurrences 
(because of the global switch, �g�) of either organization or organization 
to organization in the file myorg1, specified as parameter. The operator
[ ] refers to character class regular expression

2 $ ls -l | sed -n '/^d/p'

Explanation:
Long-listing output of ls command is piped to sed; sed command displays only those
lines which begin with the character d. 

Repeated pattern �&�
--------------------

To make the entire source pattern appear also at the destination

Example:
sed �s/director/executive director/� emp.lst
sed �s/director/executive &/� emp.lst # same as above
sed �/director/s//executive &/� emp.lst # repeated &
 				                 # remembered pattern


Extended Regular Expressions
--------------------------------

1 + This matches one or more occurrences of preceding character

2 ? This matches zero or one occurrence of preceding character

3 | This is an alternator; when placed between two patterns, it matches either of the pattern

4 () This is used to specify a list of prefixes suffixed by a common suffix, or a list of suffixes prefixed by a common prefix


Let us assume that we need to check if the entered number is an integer. These are some examples of valid integer inputs:
+7834
-4323
3433265


echo -e "-5" | sed -n -r '/^[+-]?[0-9]+$/p'

Explanation: As we have used EREs namely �?� and �+�, we need to specify �r option 
with sed. The above code checks that the user has entered a valid integer. sed checks 
if the string begins with zero or one occurrence of �+� or �-�, succeeded by one or more
occurrences of digit character.

Interval Regular Expressions
----------------------------

sed and grep uses Interval Regular Expressions (IRE). IRE uses an integer to specify the number of characters preceding a pattern. The IRE uses an escaped pair of curly braces and takes three forms: 

ch\{m\} � With this, the ch can occur m times
ch\{m,n\} � With this, the ch can occur between m and n times
ch\{m,\} � With this, ch can occur at least m times
The value of m and n cannot exceed 255.

$ echo $num
34657
$ echo $num | sed -n '/^[0-9]\{5\}$/p'; echo
34657
$ num=4578
$ echo $num | sed -n '/^[0-9]\{5\}$/p'; echo

$ num=783237
$ echo $num | sed -n '/^[0-9]\{5\}$/p'; echo


Explanation:
sed prints the number if it is a five digit number; specifying �^� and �$� at the beginning and end of the pattern is to do an exact match.  
We have used the Interval Regular Expression to match exactly five occurrences of digit character.


Tagged Regular Expressions
--------------------------

You have to identify segments of a line that you wish to extract and enclose each segment with a matched pair of escape parenthesis.
If we have to extract a number, we need to specify \([0-9]*\).
If we need to extract non-alphabetic characters, we need to specify \([^A-Za-z]*\).
Every grouped pattern automatically acquires the numeric label n, where n signifies the nth group from the left. 


1) cat teldir.txt
Rijin Thomas 99473829201
RIju  Thomas 99584738892
Hans  Bhadwj 96585494046

sed 's/\([A-Za-z]*\)*([A-Za-z]*\)/'\2,\1' teldir.txt


Explanation:
The matches from pattern space for regular expressions specified within a pair of parenthesis are remembered by sed and stored in variables named 1, 2, and so on.  Hence, we can access these matches by specifying these numbers, preceded by a backslash, �\�.


awk
====

The awk script could either be specified within a pair of quotes, or could be written into a file, and this file could be specified with the awk command.
Syntax:
awk [options] �<selection_criteria> { <action(s)> }� <input_file(s)>


options
-------

e � This is used to specify multiple scripts with a single awk command.
F � This is used to specify Input Field Separator.
f � This is used to specify a file that contains awk script.
v � This is used to pass shell variable to awk environment.


Unary
Arithmetic
Relational 
Logical

The awk operators: Unary 
----------------------------

-    	This is the unary minus.
++ 	This is the increment operator.
-- 	This is the decrement operator.

Binary operators
--------------------

+	This is the addition operator.
-	This is the subtraction operator.
*	 This is the multiplication operator.
/	 This is the division operator.
%	 This is the modulus operator.
^	 This is the exponentiation operator.	


Arithmetic assignment operators
----------------------------------

+=,   -=,    *=,    /=,     %=,   ^=

Let us suppose, we need to specify the following arithmetic statement in our code: $sum = $sum + $num;

In the above statement, we realize that both the left-hand side and right-hand side have the same operand, $sum. On such instances, we can use arithmetic assignment operators. 

Using the arithmetic assignment operator +=, the above statement can be rewritten as : 
$sum += $num;

All the other arithmetic assignment operator operates in a similar manner.


Assignment operator
---------------------

= 	This is the general assignment operator.
==   This the �equal to� operator.
 !=   This the � not equal to� operator.
 <	This the �less than� operator.
 <=	This the � less than or equal to� operator.
 >	This the �greater than� operator.
 >=	This the �greater than or equal to� operator.
 ~	This is the pattern binding equal to operator.
 !~	 This the pattern binding not equal to operator.


The awk operators: Logical
--------------------------

!   	This is the �Not� operator.
&&   	This is the logical and operator, also known as short circuit operator.
||      	This is the logical or operator, also known as short circuit operator.



The awk operators: Examples (1)
------------------------------

$ cat newemp.data
 102:agarwal:manager:GM:12/05/89:34000:32458976:2+:2:2+
 877:Karunakaran:Vice Chairman:Chairman:15/08/74:1999:28456789:1:2+:2+
 150:praveen:president:Chairman:05/08/83:34323:67894545:1:1:2+
 893:kalam:Scientist:Sr. Scientist:15/08/68:34738:45454434:2:2:2
 783:raman:vp:President:13/12/85:1933:45342323:2:2:2+
 777:karthik:president:Chairman:30/03/87:78343:9845475815:2:2:2
 989:lakshmi:clerk:manager:12/12/81:78233:199:2:2+:1
 102:mohan:manager:GM:31/12/82:34000:56443433:2:2:1
 199:sumesh:GM:VP:15/12/81:78343:89454545:2:2:2


The following awk code displays employee number, employee name, and salary of all employees whose salary is between 30000 and 40000.

 $ awk -F":" '$6>=30000 && $6<=40000 { print $1, $2, $6 }' newemp.data

  102 agarwal 34000
  150 praveen 34323
  893 kalam 34738
  102 mohan 34000


$ ls -l Sample
 total 88
 drwxr-xr-x 8 murali billjoy  4096 2009-12-16 14:00 blib 
 -rw-r--r-- 1 murali billjoy   145 2009-12-16 13:53 Changes
 drwxr-xr-x 2 murali billjoy  4096 2009-12-16 14:07 lib
 -rw-r--r-- 1 murali billjoy 22330 2009-12-16 14:05 Makefile
 -rw-r--r-- 1 murali billjoy   535 2009-12-16 13:53 Makefile.PL
 -rw-r--r-- 1 murali billjoy    61 2009-12-16 13:53 MANIFEST
 -rw-r--r-- 1 murali billjoy     0 2009-12-16 14:07 pm_to_blib
 -rw-r--r-- 1 murali billjoy  1167 2009-12-16 13:53 README
 drwxr-xr-x 2 murali billjoy  4096 2009-12-16 13:53 t


$ ls -l Sample/ | awk -F" " '{ sum += $5 } \ END { print "Sum of sizes of all files in current directory is ",sum}'

  Sum of sizes of all files in current directory is  36526


Explanation: 
The ls command with �l option pipes long-listing of files in �Sample� to awk; for every line of ls command output read by awk, awk adds value of fifth field, $5 to the variable sum and stores the result in the variable sum. In this code, it can be observed that we used arithmetic assignment operator, +=.


The awk built-in Field variables
--------------------------------

$0 � This contains entire record.
$1 � This contains first field, based on field delimiter.
$2 � This contains second field.
$x � For x is a positive integer, this contains the xth field.


ARGC � This is the number of command line arguments.
ARGV � This is the array of command line arguments; array is indexed from 0 to ARGC � 1.
ARGIND � This is the index in ARGV of the current file being processed.
ERRNO � If a system error occurs either doing a redirection for getline,  during a read for getline, or during a close(), then ERRNO will contain a string describing the error.
FILENAME � This is the name of the current input file.
FNR � This is the input record number in current input file.
FS � This is the input field separator, that is a space by default.
IGNORECASE � This controls the case-sensitivity of all regular expression and string operations. If IGNORECASE  has a non-zero value, then string comparisons and pattern matching in rules, field splitting with FS, record separating with RS, regular expression matching with  ~  and  !~,  and  the  gensub(), gsub(), index(), match(), split(), and sub() built-in functions all ignorecase when doing regular expression operations.


$ awk 'BEGIN { for (i=0; i<ARGC; i++) { print ARGV[i]; }}' Kalam Bose Raman
awk
Kalam
Bose
Raman


Explanation:
The variable ARGC stores the number of command line arguments, and the variable ARGV stores the list of arguments. Both the number of arguments and list of arguments values are inclusive of the awk command itself. 


$ awk -F":" 'BEGIN {IGNORECASE=1; } $3 ~ /manager/ { print }' newemp.lst
839:hari:gen manager:8934
888:jill:Manager:83332
744:smith:MANAGER:32333

Explanation:
When the awk built-in variable IGNORECASE is assigned a non-zero variable, 
during the pattern match, case of the pattern is ignored; hence, the output.



-F   This flag provides UNIX to host name file mapping on non-UNIX machines.
 
-L   Left justify and remove leading blanks from value. If n is nonzero it defines the width of the field,
     otherwise it is determined by the width of the value of first assignment. When the parameter receives
     a value, it is filled on the right with blanks or truncated to fit into the field. Leading zeros are removed if 
     the -Z flag is also set. This turns the -R flag off.
 
-R   Right justify and fill with leading blanks. If n is nonzero it defines the width of the field, otherwise
     it is determined by the width of the value of first assignment. The field is left filled with blanks or truncated
     from the end if the parameter is reassigned. This turns the L flag off.
 
-Z   Right justify and fill with leading zeros if the first nonblank character is a digit and the -L flag has not been
     set. If n is nonzero it defines the width of the field, otherwise it is determined by the width of
     the value of first assignment.
 
-e   Tag the parameter as having an error. This tag is currently unused by the shell and can be set 
     or cleared by the user.
 
-f   The names refer to function names rather than parameter names. No assignments can be made
     and the only other valid flag is -x.
 
-i   The name is an integer. This makes arithmetic faster. If n is nonzero it defines the output arithmetic
     base, otherwise the first assignment determines the output base.
 
-l   All uppercase characters converted to lowercase. The uppercase flag, -u is turned off.
 
-p   The output of this command, if any, is written onto the two-way pipe.
 
-r   The given names are marked read-only and these names cannot be changed by subsequent
     assignment.
 
-t   Tags the name. Tags are user definable and have no special meaning to the shell.
 
-u   All lowercase characters are converted to uppercase characters. This turns the
     lowercase flag, -l, off.
 
-x   The given names are marked for automatic export to the environment of subsequently
     executed commands.
     executed commands.
	 
	 
TYPESET
----------
Typeset actually allows you to give some special attributes to a variable like readonly(r), integer(i) etc. 

$ typeset -r year=2000
$ echo $year
$ year=2001
ksh: year: is readonly


SPLIT
----------
Used when we need to split a file into multiple files.. Can be line based and size based

split -l 30 filename filename_req 
If we hav a file name with 90 lines, then once above command is executed, we get 3 files as filename_reqaa
filename_reqab and filename_reqac with 30 lines each

to get the last to char in a string
-----------------------------------
nawk '{ print substr( $0, length($0) - 1, length($0) ) }'


To copy a file with exact time stamp
-----------------------------------
use scp -p or cp -p

Deleting b/w two patterns and print the rest
---------------------------------------------

sed '/satya/,/IBM/d' filename -> This will delete everythin from satya to IBM and print the rest!

Recursively change and replace subdirectory names
---------------------------------------------

find . -depth -name '*sairepo*' -execdir bash -c 'mv "$0" "${0//sairepo/rithomas}"' {} \;

find . -depth -name '*SAIREPO*' -execdir bash -c 'mv "$0" "${0//SAIREPO/RITHOMAS}"' {} \;

Recursively change string in all the files
------------------------------------------

find . -type f -exec sed -i 's/summarization/aggregator/gI' {} +


FInd a pattern and print lines after pattern
--------------------------------------------
if there r 10 patterns in file, below will print 1 line after every pattern

sed -n '/STATUS/,+1p' pattern_matched_file
output
STATUS REPORT FOR JOB: Base_Circuit_Issue
Generated: 2014-03-13 04:04:26
STATUS REPORT FOR JOB: CaptureInsUpdtData
Generated: 2014-03-13 04:04:43
STATUS REPORT FOR JOB: CcCmdbProduct
Generated: 2014-03-13 04:04:57
STATUS REPORT FOR JOB: Base_Circuit_Issue
Generated: 2014-03-13 04:04:26
STATUS REPORT FOR JOB: CaptureInsUpdtData
Generated: 2014-03-13 04:04:43
STATUS REPORT FOR JOB: CcCmdbProduct
Generated: 2014-03-13 04:04:57

Search a pattern and print 12 lines after it
--------------------------------------------

awk '/AC_POWER_SUPPLY/ {for(i=1; i<=12; i++) {getline; print}}' data_antony | sed -n '/FRU Status/'p | sed '3,$d' 

-->awk '/AC_POWER_SUPPLY/ {for(i=1; i<=12; i++) {getline; print}}' data_antony--> this will store  12 line after pattern into {}, then Im just grepping for FRU, status and 1st two pattern(FRU status) should carry the 1st two instance..

Sorting based on key columns
-----------------------------
sort -t -k1,2 feedname


To get only uniq values from a huge file
--------------------------------------
sort -u ASR_MISS_TOTAL_comm > ASR_MISS_TOTAL_comm_uniq

perl -ne 'if (!defined $x{$_}) { print $_; $x{$_} = 1; }' ASR_MISS_TOTAL_comm > ASR_MISS_TOTAL_comm_uniq1

Both gave same result

To read from a file and grep in another file
-------------------------------------------

fgrep -f pattern_file large_file --> search will be done on large_file
fgrep -f pattern_file -v large_file --> to print the ones which are  not there --used -v

Sending a file as an attachment from server
---------------------------------------------
uuencode "ASRbmpExtract.class" ASRbmpExtract.class| mailx -s "BMP-JAVA" pradeepkara@in.ibm.com


understanding reedbsh

See if I assign a variable with a path and I want to assign this variable to another variable, then I use ${variable1}
like this if variable1=/var/adm/perfmgr
variable2=${variable1}/daily

date +"%l:%M %p"
result is 3:04 PM

Exit Status
-----------
ls -lrt | grep thom > /dev/null
dbr9et03:/local_apps/executive/DBORL/prod/bin/sh_bin
$ echo $?
1
ls -lrt | grep rij > /dev/null
$ echo $?
0
Gives 0 only when actually executed

To remove some older files 
--------------------------
We use mtime to actuall check for the older days, we have -mtime +2--> this means exactly 2 days and older and +0 is 24hrs and older, if we use -mtime -2, so it becomes within 2 days ie, 15 hrs n stuff

echo "Removing the Dump file after 2 days retention">>${LOGFILE}
echo "------------------------------------------------">> ${LOGFILE}
if [ -f  ${exp_file_dir}/*dmp* ]
then
find ${exp_file_dir} -type f -name '*dmp*' -mtime +2 -exec rm -f {} \;
find ${exp_file_dir} -type f -name '*log*' -mtime +7 -exec rm -f {} \;
       echo "Successfully removed the file after 2 days retention\n" >> ${LOGFILE}
else
echo "Found no files older than 2days\n " >> ${LOGFILE}
fi


Regular expression
---------------------
sed 's/Linu./LINUX/g' bazaar.txt

full stop will actuall match any character, like we have *, but star will take everything after linu.. fullstop(*) will take only 1 character. 

sed syntax is 
--------------
SYNTAX:
sed [command] / pattern / [replace sequence] / [modifier] [command]

Square brackets ( [ ] ), the caret ( ^ ) and the
dollar ( $ )
-----------------------------------------------
Square brackets mean a range of characters. If we tried [abc],it means match a single character which is either  'a' or'b' or  'c'.
A caret ( ^ ) matches a start of line and the dollar ( $ ) the end of the line

write a sed expression that's going to match lines (not search and replace as before, )
that begin with 'a', 'e' or i and print ( p ) them.

####sed '/^[aeI]/p' bazaar.txt

Now if I want not to match some of the characters then I will use the caret inside the square brackets.
#### sed '/^[^aeEI]/p'
This causes every line that does NOT begin with 'a', 'e', 'E' or i to be printed. What's
happening here? Well, the caret inside the square bracket means "do not match".

####sed '/^[^aeEI]/d'


Just the same way that the caret means the beginning of the line, the $ means the end

####sed '/[aeEI]$/!d' bazaar.txt
"don't ( ! ) delete any line that ENDS in either an 'a', an 'e' an 'E' or

We've used the following expressions:
.      any single character
[ ]    a range of characters
^      start of line (when outside [ ])
^      do not (when inside [ ])
$      end of line


Blank Line (^$)
----------------

Suppose I want to delete all the blank lines then I use it as below
#### sed '/^$/d' filename

####sed '/[aeEI]$/!d' bazaar.txt | sed '/^$/d' -- To remove the blank lines.. 

xxxxx--> However, instead of using a pipe we can have both the sed in one only as below.. as this reduces the time of execution. u can check it by running the time command
####time sed '/^[^aeEI]/d' bazaar.txt |sed '/^$/d' |nl
####time sed '/^[^aeEI]/d;/^$/d' bazaar.txt |nl

####sed '/^[^aeIE]/d;/^$/d' bazaar.txt | 

Let's update our list of patterns:
character pattern
. any single character
[ ] a range of characters
^ start of line (when outside [ ])
^ do not (when inside [ ])
$ end of line
* 0 or more of the previous pattern
+ 1 or more of the previous pattern
\{n\}
\{n, \}+
\{n,m\}
The plus operator ( + )

The word encapsulation characters are < and >,
----------------------------------------------
 but naturally, since these hold
special meaning in the shell (and in fact in sed too), we need to escape them, hence
the \< and \>.
The second sed should produce closer to what you may have been expecting and
would match fox, the, bar, bat, its, joe, etc....
Returning from detour to our discussion on
curly braces �
The above RE ( sed \%\<[a-z][a-z][a-z]\>%p' /usr/share/dict/words ) is a little long,
so we could shorten it using the splat to:
sed '/\<[a-z]\{3\}\>/p' /usr/share/dict/words

Placeholders and word boundaries
--------------------------------
Suppose there is a scenario where u want have a file columns.txt and u have 2 columns in it "Name Age". Now you want to have the output with 1st Age Column then Name column ie, swap so u do it in simple as below

first try and develop a
pattern that matches name and a pattern that matches age. Notice that the two
columns in the file are separated by a single space. The expression for the name
column would be:
[a-z]*
Assuming that no one in our file is 100 years or older we can use the following
expression to match the values of the age column:
[0-9]\{1,2\}-----> This 1,2 is to repeat twice ok--> shud be like [0-9]{1,2} can be any 2 digit frm 0-9
That should match any age (in the file) because it means match any digit in the range
0-9 a minimum of once but a maximum of twice. So it should match a person whose
age is: 1, 9 or 99
#### sed '/^[a-z]* [0-9]\{1,2\}$/p' --- This will only match and print, to swap I will do like below

Also to swap I will have to keep both the patterns in parenthesis () and that also needs to be escaped
####sed '/^\([a-z]*\) \([0-9]\{1,2\}\)$/\2,\1'  --> This will swap it other way

The tr command
-------------
Used to translate from uper to lower or vise versa
####cat columns.txt | tr '[a-z]' '[A-Z]'

####free | tr -s ' '  --> This will actually remove all multiple spaces between the fields
say if I have 
$ echo "mans    a,smnsnsn       ahshsha     ahhshsh" | tr -s " " ----> mans a,smnsnsn ahshsha ahhshsh
cut command
------------
see one thing is we can cut the fields, then characters ok
1st I will delimit then I mention the fields ok
cat /etc/passwd | grep -i feedadm
feedadm:x:20108:10005:FEEDADM Account:/export/home/feedadm:/bin/ksh

if I want field 2 to 5 and here dlimiter is :, then

####bash-2.03$ cat /etc/passwd | grep -i feedadm | cut -d":" -f2-5
x:20108:10005:FEEDADM Account

if i want only 2nd and 5th field
bash-2.03$ cat /etc/passwd | grep -i feedadm | cut -d":" -f2,5
x:FEEDADM Account

####bash-2.03$ cat /etc/passwd | grep -i feedadm | cut -c2-5
eeda
####bash-2.03$ cat /etc/passwd | grep -i feedadm | cut -c2-20,30-35
eedadm:x:20108:1000 Accou

Paste command
---------------
if I need to stick two files with a delimiter then I can use paste -d

say I have a file with cat rijin.txt
rijin
rijin

an another file with cat rijin1.txt1
thomas
thomas

####paste -d ":" rijin.txt rijin1.txt1
o/p --> 
rijin:thomas
rijin:thomas

uniq command
--------------
if we have any duplicate entries we can remove it using the uniq command.. 

####cat rijin1.txt | uniq ----> gives u thomas

grep command
------------
####grep "[hH][aA][Mm]" /etc/passwd
will give
which would match all of the following patterns:
hAM
HaM
HAm
####grep "Linu." bazaar.txt


grep (naturally) has other switches that are useful:
switch action
-B 5 display the context - i.e. 5 lines of
context before a match
-A 3 display the context - 3 lines of context
after a match
-v reverses the pattern
-n label every line
The following command would grep every line except the lines that have the pattern
Linus/linus/Linux/linux etc. and it would label every line because of the -n switch.
####grep -vn "[Ll]inu." bazaar.txt
If you wanted to grep on a whole stack of files then you could:
grep -n "Linux." *
which would show you the filename and the line number of the line that contains the
pattern.

if [ $(grep -c "successfully" /export/dsadm/dw/logs/Dw_Proc.log) -ne 0 ]
> then
> echo "hi"
> fi

integer arithmetic
------------------
There are numbr of ways 
1) enclose your expression in double round brackets:
$(())
I=10
####$((I=I+5))
echo $I --> 15
####$((I=(15*I)-26))

i=0
i=$(expr i+1)

Quotes
------
If you're using double quotes and you need to use double quotes within a double
quoted string, you need to escape the double quotes. You want to print out a
'$NAME' and since the $ is a special character, you need to escape the dollar itself.
So, the answer is:
echo "Hello. The name in \"\$NAME\" is $NAME".

Using a special variable called $#
----------------------------------

String Test Numeric Test
----------------------------
= -eq
!= -neq
<= -le
>= -ge
> -gt
< -lt

variable:OFFSET:LENGTH 
------------------------
FirstName=hamish
echo ${FirstName:0:3} will give ham

To count the number of pipe in a file
--------------------------------------
awk -F "|" {print NF-1} filename 

Converting unstructured to structured
---------------------------------------
#### Suppose I want to extract multople patterns and then print in in the form of columns something like converting unstructured to structured. say if I want to check for the pattern "STATUS REPORT FOR JOB" , "Job start time" and "Job start time"

Rijin@rijthoma ~
$ cat pattern_match_log

**************************************************
STATUS REPORT FOR JOB: Base_Circuit_Issue
Generated: 2014-03-13 04:04:26
   Job start time=2013-10-04 06:46:41
   Job end time=2013-10-04 06:46:43
   Job elapsed time=00:00:02
   Job status=1 (Finished OK)
**************************************************
STATUS REPORT FOR JOB: CaptureInsUpdtData
Generated: 2014-03-13 04:04:43
   Job start time=2013-06-07 12:45:24
   Job end time=2014-03-13 04:04:43
   Job elapsed time=6687:19:19
   Job status=99 (Not running)
**************************************************
STATUS REPORT FOR JOB: CcCmdbProduct
Generated: 2014-03-13 04:04:57
   Job start time=2013-06-07 12:50:26
   Job end time=2014-03-13 04:04:57
   Job elapsed time=6687:14:31
   Job status=99 (Not running)$
**************************************************


cat pattern_match_log | awk '/'"STATUS REPORT FOR JOB"'/ {printf $5","};/Job start time/ {printf $3 " " $4","};/Job end time/ {printf "%s", $3","};/'"Job status"'/ {printf "%s", $3 " " $4"\n"}' |  sed -e 's/(//g' -e 's/)//g'  -e 's/time=//g' 


output is 

Base_Circuit_Issue,2013-10-04 06:46:41,2013-10-04,Finished O
CaptureInsUpdtData,2013-06-07 12:45:24,2014-03-13,Not runnin
CcCmdbProduct,2013-06-07 12:50:26,2014-03-13,Not running$
Base_Circuit_Issue,2013-10-04 06:46:41,2013-10-04,Finished O
CaptureInsUpdtData,2013-06-07 12:45:24,2014-03-13,Not runnin
CcCmdbProduct,2013-06-07 12:50:26,2014-03-13,Not running$

one more similar awk -> 
awk ' /'"STATUS REPORT FOR JOB"'/ {flag=1;next} /'"STATUS REPORT FOR JOB"'/{flag=0} flag {if (/Job start time/) {print $0}  else if (/Job end time/) {print $0} else if (/Job status/)  print $0}' pattern_match_log


Shell to ftp automatically
-----------------------------
ftp -vin <<!
open ${FTP_SERVER}
user ${FTP_LOGIN} ${FTP_PASSWORD}
cd ${FTP_PATH}
lcd ${OUTPUT_DIR}
put active.txt
bye
!


Using awk -v if you using a shell variable
==========================================

for var in `cat /ftphome/ldw/ldd/ut/data/BMP/ASR/work/missing_san`
do  
nawk -v VAR=${var} -F "|" '{if ($1 == VAR || $3 == VAR)print $0}' /ftphome/ldw/ldd/ut/data/BMP/ASR/work/ASR_asradm_today_ban_san_ckt_bk >> final_San
done

PUSHING A PROCESS RUNNING ON SHELL TO BACKGROUND
================================================
These steps r the ones to follow :-
1) Cntrl-z and stopp process, you come out of promt
2) bg %1 (1 or that number which shows)
once bg executed then it resumes in background

$ find . -name rijin
./DBORL/prod/bin/sh_bin/rijin
^Z								xxx-> hit cntr -z
[1]+  Stopped                 find . -name rijin

Just tried ps -ef 
 ps -ef | grep find
executiv  7739  6195  0 16:26:51 pts/3    0:00 find . -name rijin
executiv  7814  6195  0 16:26:58 pts/3    0:00 grep find

2) put to background 
$ bg %1   xxx-> starts running, only prob is if shell disconnected the proc gets disconnected
[1]+ find . -name rijin &
dbr9et03:/local_apps/executive
$ ./DBORL/prod/bin/rijin
./DBORL/prod/conf/rijin
./DBORL/rijin

==============================================
How to run  last executed find command in Unix � Example 1
find . -name "*.java"

================
How to find files which has been modified less than one day, minute or hour  in Unix:
find . -mtime 1  (find all the files modified exact 1 day)
find . -mtime -1 (find all the files modified less than 1 day)
find . -mtime +1 (find all the files modified more than 1 day)
==================================

How to find all the files and directories which holds the 777 permission in Unix box � Exmaple 3
find . -perm 644
==========================
Case insensitive search using find in Unix
find . �iname "error" �print ( -i is for ignore )
=========================

How to delete temporary files using find command in Unix?
find . -name "*.tmp" -print | xargs rm �f
=========================
How to find all text file which contains word Exception using find command in Unix ?
find . �name "*.txt" �print | xargs grep "Exception"
==========================
Example 7 -  Finding files only in current directory not searching on sub directories:
find . -maxdepth 1 -type f -newer first_file
==============================
Last modified 15 minutes ago, only look at the current directory. (No sub-directories)
find . -type f -cmin 15 -prune
=============================
How to find files based on size in Unix and Linux
find . -size +1000c -exec ls -l {} \;
===================================
if you want to find all the files within a range you can use find command as in below example of find:
find . -size +10000c -size -50000c -print
===================================
How to find files some days older and above certain size
find . -mtime +10 -size +50000c -exec ls -l {} \;
===================================
How to use find command on file names with space in Unix:
javin@testenv1:~/test find . -name "*equity*" -print
./cash equity trading ./equity~
======================================

============================================================
NETWORK COMMANDS
======================
hostname

hostname with no options displays the machines host name
hostname �d displays the domain name the machine belongs to
hostname �f displays the fully qualified host and domain name
hostname �i displays the IP address for the current machine


ping
It sends packets of information to the user-defined source. If the packets are received, the destination device sends packets back. Ping can be used for two purposes

1. To ensure that a network connection can be established.
2. Timing information as to the speed of the connection.

If you do ping www.yahoo.com it will display its IP address. Use ctrl+C to stop the test.

ifconfig
View network configuration, it displays the current network adapter configuration. It is handy to determine if you are getting transmit (TX) or receive (RX) errors.


netstat
Most useful and very versatile for finding connection to and from the host. You can find out all the multicast groups (network) subscribed by this host by issuing "netstat -g"

netstat -nap | grep port will display process id of application which is using that port
netstat -a  or netstat �all will display all connections including TCP  and UDP  
netstat --tcp  or netstat �t will display only TCP  connection
netstat --udp or netstat �u will display only UDP  connection
netstat -g will display all multicast network subscribed by this host.

nslookup
If you know the IP address it will display hostname. To find all the IP addresses for a given domain name, the command nslookup is used. You must have a connection to the internet for this utility to be useful.
E.g. nslookup blogger.com

You can also use nslookup to convert hostname to IP Address and from IP Address from hostname.

traceroute
A handy utility to view the number of hops and response time to get to a remote system or web site is traceroute. Again you need an internet connection to make use of this tool.


finger
View user information, displays a user�s login name, real name, terminal name and write status. this is pretty old unix command and rarely used now days.

telnet
Connects destination host via telnet protocol, if telnet connection establish on any port means connectivity between two hosts is working fine.
telnet hostname port   will telnet hostname with the port specified. Normally it is used to see whether host is alive and network connection is fine or not.

=================
Unix: sed to change characters in particular position
Suppose you have big file. You want to change character 100-110 with some text. So, simply you want to interchange first 4 characters with the next 4 characters in each line. In these kind of scenarios, sed one liners will be very useful.

See few examples below:

$cat a.tmp
20090918ARPITH2010011634
20090918ARPITH2010012050
20090905ARPITH2010011382
20090824ARPITH2010012075
20090921ARPITH2010012075
--Follwing sed command will interchange first 4 digits with next 4 digits.
$sed 's:\([0-9]\{4\}\)\([0-9]\{4\}\):\2\1:' a.tmp
09182009ARPITH2010011634
09182009ARPITH2010012050
09052009ARPITH2010011382
08242009ARPITH2010012075
09212009ARPITH2010012075
Explanation:
\([0-9]\{4\}\) It defines first four digits. If you want to replace any 4 characters not only digit then replace [0-9] with . like \(.\{4\}\)
\ It is to escape (
() This bracket will define different groups. It is used for backreference and can be used again using \1 or \2 etc based on its occurence.
[0-9] Check for digits
\{4\} Four occurence of digit in [0-9]

\2\1 It says first put second set and then first set.

Following sed command will interchange first 8 characters/digits with next 6 characters. And it will also seperate each set with space.
$sed 's:\(.\{8\}\)\(.\{6\}\):\2 \1 :' a.tmp
ARPITH 20090918 2010011634
ARPITH 20090918 2010012050
ARPITH 20090905 2010011382
ARPITH 20090824 2010012075
ARPITH 20090921 2010012075

Following command will replace characters from 9 to 15 with text "NIRAVB"
sed 's:\(.\{8\}\)\(.\{6\}\):\1NIRAVB:' a.tmp
20090918NIRAVB2010011634
20090918NIRAVB2010012050
20090905NIRAVB2010011382
20090824NIRAVB2010012075
20090921NIRAVB2010012075

Limitation: If you specify more than 255 in curly braces "\{ \}", you will get following error.
$sed 's:\(.\{256\}\)\(.\{6\}\):\1NIRAVB:' a.tmp
sed: Function s:\(.\{256\}\)\(.\{6\}\):\1NIRAVB: cannot be parsed.

Solution: To overcome the issue you can break 335 in 255 + 80. As I have shown in following example. Here I want to change character 335 to 338 with text "TEST"
$cat a.tmp
20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005
20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005
20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005

$sed 's:\(.\{335\}\)\(.\{4\}\):\1TEST:' a.tmp
sed: Function s:\(.\{335\}\)\(.\{4\}\):\1TEST: cannot be parsed.

$sed 's:\(.\{255\}\)\(.\{80\}\)\(.\{4\}\):\1\2TEST:' a.tmp

20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000TEST00000000000000000000000000000000005
20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000TEST00000000000000000000000000000000005
20090913476178957893478958937589078903745897123890789074589076238904758906179038759081738904715890378904518978907348907579487592763785691287589072386590827890752890475890274890768902748906892748976898000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000TEST00000000000000000000000000000000005

xxxxx-> I had to remove chars from 1232 to 1297(65 chars).. i used below sed but it gave performace so used below perl

sed 's/\(.\{255\}\)\(.\{255\}\)\(.\{255\}\)\(.\{255\}\)\(.\{212\}\)\(.\{65\}\)/\1\2\3\4\5/g' feed_1466 > fix_1466



Kernal version
---------------
       root@sandy04> uname -r
       2.6.32-358.17.1.el6.x86_64
}}}


Tar -xvf -> to Untar .xz
tar -


perf record -e block:block_rq_issue -ag
 1021  perf report --stdio
 
TO CREATE PERF DATA
==================
mkdir /tmp/perf
cd /tmp/perf
perf record -a -g
perf archive

To Collect perf data
==================
https://access.redhat.com/solutions/503663
Extract the archive file perf.data.tar.bz2 into ~/.debug
tar xf perf.data.tar.bz2 -C ~/.debug

Open the perf.data file using following command:
perf report -i perf.data
perf report --stdio
perf report -i perf.data -s overhead_sys --stdio --showcpuutilization


============================
To create SOS report
==================
https://access.redhat.com/solutions/3592

sosreport
sosreport --batch --> Takes interactive values from RHN config files.. it creates in /tmp

=======================
35) To bring up an vlan tagged interface bond0.3979:1
ifconfig bond0.3979:1 172.16.5.5 netmask 255.255.255.0 broadcast 1172.16.3.255 up
===========================================================

36) if i have a process send to bg and then I execute a command and later wants the bg process to complete and process..
-> use wait
root@blr08> while [ 20 ] ; do sar -A 1 ; done > /dev/null &
[1] 1041
root@blr08> 
root@blr08> echo hi
hi
root@blr08> wait
echo "hi after wait"
prints hi after 20 sec

===============================
How to get child process from parent process

pgrep -P $parent_process

================================

1) modprobe -> this command is used to view/add/remove kernal modules

		### This lists total kernal modules
		$ modprobe -l | less  
		kernel/arch/x86/kernel/cpu/mcheck/mce-inject.ko
		kernel/arch/x86/kernel/cpu/cpufreq/e_powersaver.ko
		kernel/arch/x86/kernel/cpu/cpufreq/p4-clockmod.ko
		
		## This lists actuall loaded modules in kernal
		$ lsmod | less  
		soundcore          7264   1 snd
		ppdev                6688   0
		
		## To add a module to kernal
		$ sudo modprobe vmhgfs  ## jus modprobe n modulename
		$ lsmod | grep vmhgfs
		vmhgfs                 50772  0
		
		
		## To remove a module from kernal
		modprobe -r vmhgfs	
		
		
4) ifconfig -a and ip addr show
		shows bond/interface /netmask details-->  Read abt setting up network, why bond n wats eth etc
		Bond is something which aggregates multiple network interfaces to a single logical bond..  so waht we do is we create a bond with taking 2 interfaces say(eth0 and eth1).so what we do is in vi /etc/sysconfig/network-scripts/ifcfg-eth1 we set master to bond0 similarly set it for ifcfg-eth0 and do "# service network restart"..
		
5) echo 'c' > /proc/sysrq-trigger --> To crash system

6)ssh delay -> do ssh -v root@server to see debug and see where its delaying.. issue occured prev for GSS authentication, commented in etc/ssh_conf and restarted ssh services

7) If I want to create a 1 GB file 
   dd if=/dev/zero of=tempfile1 bs=100M count=10
   
8) Expect script to scp a file
#! /usr/bin/expect
set timeout -1
spawn scp /home/iserver/rijin root@$10.58.134.188:
expect "password:"
send "yt_xk39b\r"
interact

9) lsblk -> Gives me proper information abt disk etc (sda,sda2)

10) to check image file and then see contents
   --> file initramfs-2.6.32-388.el6.bz963843.x86_64.img
initramfs-2.6.32-388.el6.bz963843.x86_64.img: gzip compressed data
   --> gunzip if gz, unxz filename if xz file extension
   --> cpio -i < initramfs-2.6.32-388.el6.bz963843.x86_64(to uncompress)
   --> find | cpio -H newc -o > ../new_initrd_file --> to repack
   --> gzip -9 new_initrd_file

11) To read a pcap file
	--> tshark -V -r 56.pcap icmpv6 (V-> it gives packet summary n r -> to read)
	--> Also u can use tcpdump -r file.pcap
	
	if u want to check for ip specifically
	 --> tshark -r tcpdumppccbih-201004201.pcap -Y 'ip.addr == 10.70.22.150 && ip.addr == 10.48.35.35' | head -n 10
	
12) Strace -> Gives call info about the running prog(http://www.thegeekstuff.com/2011/11/strace-examples/)
	--> strace ls
	-->  strace -e open ls  (using -e , I can trace a call(open) internally wat doing)
	--> strace -p -o log.txt (Monitor running process and output to log.txt)
	--> strace  -t -e open ls (This will print time for each strace o/p)	
	--> strace -r ls (This will give time taken for each calls internally like open call taking 30 secs etc)
	
13) To untar tar.xz
tar xvfJ  sosreport-pccbih-202-20150316160040-9d1b.tar.xz

14) To get eth0/eth1 during boot add this to kick start file "net.ifnames=0 biosdevname=0"

15) #!/usr/bin/env stap

    probe begin {
      printf("%-26s %-8s %-16s %-5s %-16s %6s %-16s\n",
             "TIME", "SPID", "SNAME", "RPID", "RNAME", "SIGNUM", "SIGNAME")
    }

    probe signal.send {
        if (@1 == pid_name) {
            if (sig_name == @2) {
                printf("%-26s %-8d %-16s %-5d %-16s %-6d %-16s\n",
                    ctime(gettimeofday_s()), pid(), execname(),
                    sig_pid, pid_name, sig, sig_name)
            }
        }
    }
	
16) if i want to umount a FS and if a busy message comes
    -> 1st kill process accessing the FS -> fuser -km /dev/mount
	-> Then umount /dev/mount
17) To see list of depepndent libraries a command/script needs
	ldd /usr/bin/ls --> Make sure give full abosolute path for the command
	
18) RLIMIT_NPROC to limit the number of process per user... this can be set in /etc/security/limits.conf --> rijin - nproc unlimited (where rijin s user)
  The default limits are 
	-->	the Linux kernel at boot time (to the init process)cat /proc/1/limits,
	-->	inheritance, from the parent process' limits (at fork(2) time),
	-->	PAM when the user session is opened (can replace kernel/inherited values),
	-->	the process itself (can replace PAM & kernel/inherited values, see setrlimit(2)).
	
19) if you get oracle not found -> check if they have used correct SID, this is the DB name..then bring-up instance using "startup"..there is a dbs path where u can see if startup fails.. it reads from path /u01/app/oracle/product/11.2.0/db_1/dbs.. u must find init_dbdc03 if sid is dbdc03..

20) ls -lrth -> gives size of the files in Mega/GB -> powerful command

21) To extract jar file -> unzip java.jar
    To repack the dir to jar -> jar cf tools.jar /tools
==================================
To extract RPM
==================

rpm2cpio php-5.1.4-1.esp1.x86_64.rpm | cpio -idmv

================
To remove a special character file
--> use ""
eg) rm -rf "~"

Making a shell script as a daemon
=================================

1)My script which I need to trigger automatically after completion

eg) [root@hadoopmasternode init]# cat /root/test.sh 
echo hi >> /tmp/rij.out
sleep 2




2) To make above script as a daemon,

In /etc/init create a conf file with your script name like below. This conf file keeps spawning using initctl, My scriptname is test.sh, so creating test.conf

[root@hadoopmasternode init]# cat test.conf 
chdir /root 
exec sh test.sh
#expect fork
respawn 
[root@hadoopmasternode init]# 



3) Run "start test", this will trigger the above daemon ie(test.conf)

eg) 

[root@hadoopmasternode init]# start testing
testing start/running, process 3437
[root@hadoopmasternode init]# 



im getting hi continuosly after it completes..tats it

 tailf /tmp/rij.out
hi
hi
hi
hi
hi
hi
hi
hi
hi
hi
hi

To remove last column using awk 
===============================
echo "rij,1231,were" | awk -F "," '{$NF=""}1' FS=, OFS=,
--> rij,1231,

To get all parameter except 1st
===================
"${@:2}"


TO remove 1 line before pattern and 9 lines after pattern
=====================================

sed '$N;$N;N;/opt\/nsn\/ngdb\/ContentAndAdaptation\/usage_job/{$d;N;N;N;N;N;N;N;N;N;d};P;D' AdapterRPMGen_Scripts/pom.xml

Using screen command: 
=====================

Step 1: Type screen command and enter, 
Step 2: close terminal, it will show detached in screen -ls, thats ok, 
step 3: reattach by screen -r "id"
step 4: To scroll up and down in a screen window: In Mac -> press ctrl + a + esc, after that use up and down arrow.



CPU info:
--------

scpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                8
On-line CPU(s) list:   0-7
Thread(s) per core:    1
Core(s) per socket:    1
Socket(s):             8
NUMA node(s):          1
Vendor ID:             GenuineIntel
CPU family:            6
Model:                 79
Model name:            Intel(R) Xeon(R) Gold 6130 CPU @ 2.10GHz
Stepping:              0
CPU MHz:               2095.078
BogoMIPS:              4190.15
Hypervisor vendor:     VMware
Virtualization type:   full
L1d cache:             32K
L1i cache:             32K
L2 cache:              1024K
L3 cache:              22528K


1) Dev cluster(tki-hoinf-t2109 ~ 12)
16GB RAM, 8 CPU's, 1 Core per socket, 0 Swap MarkLogic process ran twice as faster compared to the UAT cluster for the same workload.

2) Test/UAT Cluster:
RHEL cluster(tki-hoinf-t2006~2008) 24GB RAM, 8CPU, 4 Core per Socket, 6GB Swap Marklogic completes in couple of hours. This is the fastest cluster.
Replacement cluster(TKI-HOINF-T2115 ~ 2117): 8GB RAM, 8CPU, 1 Core per socket, 8GB Swap Memory issues and process restarts. This is the slowest cluster.


3) Prod Cluster: RHEL cluster(tki-hoinf-t2006~2008) 16GB RAM, 8CPU, 4 Core per Socket, 6GB Swap This is a faster compared to the dev configuration. Only difference is, it is a Quadcore CPU
